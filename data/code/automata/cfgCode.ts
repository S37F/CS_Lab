
export const cfgCode = {
  'Python': `# NOTE: This is an implementation of the CYK algorithm, which determines
# if a string can be generated by a Context-Free Grammar in Chomsky Normal Form.

def cyk_parse(grammar, input_string):
    """
    grammar = {
        'S': ['AB', 'BC'],
        'A': ['BA', 'a'],
        'B': ['CC', 'b'],
        'C': ['AB', 'a']
    }
    """
    n = len(input_string)
    table = [[set() for _ in range(n)] for _ in range(n)]

    # Fill diagonal with terminals
    for i in range(n):
        for var, prods in grammar.items():
            if input_string[i] in prods:
                table[i][i].add(var)

    # Fill the rest of the table
    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            for k in range(i, j):
                for var, prods in grammar.items():
                    for prod in prods:
                        if len(prod) == 2: # Rule is of form A -> BC
                            B, C = prod[0], prod[1]
                            if B in table[i][k] and C in table[k+1][j]:
                                table[i][j].add(var)

    # Check if start symbol 'S' is in the top-right cell
    return 'S' in table[0][n-1]

# Example grammar in Chomsky Normal Form
grammar_cnf = {
    'S': {'AB', 'BC'},
    'A': {'BA', 'a'},
    'B': {'CC', 'b'},
    'C': {'AB', 'a'}
}
test_string = "baaba"
can_be_generated = cyk_parse(grammar_cnf, test_string)
print(f"String '{test_string}' can be generated by the grammar: {can_be_generated}")
`,
  'Java': `import java.util.*;

// NOTE: This implements the CYK algorithm for a CFG in Chomsky Normal Form.
public class CYKParser {

    public static boolean parse(Map<String, Set<String>> grammar, String input) {
        int n = input.length();
        Set<String>[][] table = new HashSet[n][n];

        for (int i = 0; i < n; i++) {
            for(int j = 0; j < n; j++) {
                table[i][j] = new HashSet<>();
            }
        }

        for (int i = 0; i < n; i++) {
            String terminal = String.valueOf(input.charAt(i));
            for (Map.Entry<String, Set<String>> rule : grammar.entrySet()) {
                if (rule.getValue().contains(terminal)) {
                    table[i][i].add(rule.getKey());
                }
            }
        }

        for (int len = 2; len <= n; len++) {
            for (int i = 0; i <= n - len; i++) {
                int j = i + len - 1;
                for (int k = i; k < j; k++) {
                    for (Map.Entry<String, Set<String>> rule : grammar.entrySet()) {
                        for (String prod : rule.getValue()) {
                            if (prod.length() == 2) {
                                String B = prod.substring(0, 1);
                                String C = prod.substring(1);
                                if (table[i][k].contains(B) && table[k + 1][j].contains(C)) {
                                    table[i][j].add(rule.getKey());
                                }
                            }
                        }
                    }
                }
            }
        }

        return table[0][n - 1].contains("S");
    }

    public static void main(String[] args) {
        Map<String, Set<String>> grammar = new HashMap<>();
        grammar.put("S", Set.of("AB", "BC"));
        grammar.put("A", Set.of("BA", "a"));
        grammar.put("B", Set.of("CC", "b"));
        grammar.put("C", Set.of("AB", "a"));
        
        String input = "baaba";
        boolean result = parse(grammar, input);
        System.out.println("String can be generated: " + result);
    }
}
`,
  'C++': `#include <iostream>
#include <string>
#include <vector>
#include <set>
#include <map>

// NOTE: This implements the CYK algorithm for a CFG in Chomsky Normal Form.
using Grammar = std::map<std::string, std::set<std::string>>;

bool cykParse(const Grammar& grammar, const std::string& input) {
    int n = input.length();
    std::vector<std::vector<std::set<std::string>>> table(n, std::vector<std::set<std::string>>(n));

    for (int i = 0; i < n; ++i) {
        for (const auto& rule : grammar) {
            if (rule.second.count(std::string(1, input[i]))) {
                table[i][i].insert(rule.first);
            }
        }
    }

    for (int len = 2; len <= n; ++len) {
        for (int i = 0; i <= n - len; ++i) {
            int j = i + len - 1;
            for (int k = i; k < j; ++k) {
                for (const auto& rule : grammar) {
                    for (const auto& prod : rule.second) {
                        if (prod.length() == 2) {
                            std::string B = prod.substr(0, 1);
                            std::string C = prod.substr(1, 1);
                            if (table[i][k].count(B) && table[k + 1][j].count(C)) {
                                table[i][j].insert(rule.first);
                            }
                        }
                    }
                }
            }
        }
    }

    return table[0][n - 1].count("S");
}

int main() {
    Grammar grammar = {
        {"S", {"AB", "BC"}},
        {"A", {"BA", "a"}},
        {"B", {"CC", "b"}},
        {"C", {"AB", "a"}}
    };
    std::string input = "baaba";
    bool result = cykParse(grammar, input);
    std::cout << "String can be generated: " << std::boolalpha << result << std::endl;
    return 0;
}
`
};
